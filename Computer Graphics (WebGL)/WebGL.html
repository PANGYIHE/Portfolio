<head>
    <script src="gl-matrix-min.js"></script>
    <script>
        function main() {
            canvas = document.querySelector("#glCanvas");
            canvas.addEventListener("mousedown", doMouseDown, false);
            // Initialize the GL context
            const gl = canvas.getContext("webgl");

            // Only continue if WebGL is available and working
            if (gl === null) {
                alert("Unable to initialize WebGL. Your browser or machine may not support it.");
                return;
            }

            // Vertex shader program
            const vsSource = `
                attribute vec4 aVertexPosition;
                attribute vec3 aVertexNormal; // ** LIGHTING **
                attribute vec4 aVertexColor;

                uniform mat4 uNormalMatrix; // ** LIGHTING **
                uniform mat4 uModelViewMatrix;
                uniform mat4 uProjectionMatrix;

                varying lowp vec4 vColor;
                varying highp vec3 vLighting; // ** LIGHTING **

                void main(void) {
                    gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
                    vColor = aVertexColor;

                    // Apply lighting effect // ** LIGHTING **

                    highp vec3 ambientLight = vec3(0.3, 0.3, 0.3);
                    highp vec3 directionalLightColor = vec3(1, 1, 1);
                    highp vec3 directionalVector = normalize(vec3(0.85, 0.8, 0.75));

                    highp vec4 transformedNormal = uNormalMatrix * vec4(aVertexNormal, 1.0);

                    highp float directional = max(dot(transformedNormal.xyz, directionalVector), 0.0);
                    vLighting = ambientLight + (directionalLightColor * directional);
                }
            `;

            // Fragment shader program
            const fsSource = `
                varying lowp vec4 vColor;
                varying highp vec3 vLighting; // ** LIGHTING **

                void main(void) {
                    gl_FragColor = vec4(vColor.rgb * vLighting, vColor.a); // ** LIGHTING **
                }
            `;

            // Initialize a shader program; this is where all the lighting
            // for the vertices and so forth is established.
            const shaderProgram = initShaderProgram(gl, vsSource, fsSource);

            // Collect all the info needed to use the shader program.
            // Look up which attribute our shader program is using
            // for aVertexPosition and look up uniform locations.
            const programInfo = {
                program: shaderProgram,
                attribLocations: {
                    vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                    vertexNormal: gl.getAttribLocation(shaderProgram, 'aVertexNormal'), // ** LIGHTING **
                    vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor'),
                },
                uniformLocations: {
                    projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                    modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
                    normalMatrix: gl.getUniformLocation(shaderProgram, 'uNormalMatrix'), // ** LIGHTING **
                }
            };

            // coordinate to draw box
            const positionsBox = [
               // Front face
               -1.0, -1.0,  1.0, // 0
                1.0, -1.0,  1.0, // 1
                1.0,  1.0,  1.0, // 2
                -1.0,  1.0,  1.0, // 3

                // Back face
                -1.0, -1.0, -1.0, // 4
                -1.0,  1.0, -1.0, // 5
                1.0,  1.0, -1.0, // 6
                1.0, -1.0, -1.0, // 7

                // Top face
                -1.0,  1.0, -1.0, // 8
                -1.0,  1.0,  1.0, // 9
                1.0,  1.0,  1.0, // 10
                1.0,  1.0, -1.0, // 11

                // Bottom face
                -1.0, -1.0, -1.0, // 12
                1.0, -1.0, -1.0, // 13
                1.0, -1.0,  1.0, // 14
                -1.0, -1.0,  1.0, // 15

                // Right face
                1.0, -1.0, -1.0, // 16
                1.0,  1.0, -1.0, // 17
                1.0,  1.0,  1.0, // 18
                1.0, -1.0,  1.0, // 19

                // Left face
                -1.0, -1.0, -1.0, // 20
                -1.0, -1.0,  1.0, // 21
                -1.0,  1.0,  1.0, // 22
                -1.0,  1.0, -1.0, // 23




            ];

            gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque
            gl.clearDepth(1.0);                 // Clear everything
            gl.enable(gl.DEPTH_TEST);           // Enable depth testing
            gl.depthFunc(gl.LEQUAL);            // Near things obscure far things

            const fieldOfView = 58 * Math.PI / 180;   // in radians
            const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
            const zNear = 0.1;
            const zFar = 100.0;
            const projectionMatrix = mat4.create();

            // Put perspective matrix into "cameraMatrix" variable
            var cameraMatrix = mat4.perspective(projectionMatrix,
                                fieldOfView,
                                aspect,
                                zNear,
                                zFar);

            // Translate camera using sliders
            cameraMatrix = mat4.translate(cameraMatrix,cameraMatrix,[-cMoveX, -cMoveY, -cMoveZ]);
            // Roatate camera a bit for nice effect
            let cameraRotateDefault = 30 * 0.0174533;
            cameraMatrix = mat4.rotate(cameraMatrix,cameraMatrix,cameraRotateDefault,[0,1,0]);

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // Clear the canvas before we start drawing on it.

            // modelViewMatrix declaration (make the drawing after this centered to 0,0,0 origin coordinate)
            let modelViewMatrix = mat4.create();

            // Declare colorsBuffer & initialize it
            var colorsBuffer = initBuffers(gl,positionsBox,greyColors);

            // Translate Parent object on slider
            mat4.translate(modelViewMatrix,modelViewMatrix,[pMoveX,pMoveY,pMoveZ]);
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ);

            // DRAW SPINE BASE
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.15,0.15,2.5]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,3,0.2]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

           
             // ********************************************
            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create();

            // Translate Parent object on slider
            mat4.translate(modelViewMatrix,modelViewMatrix,[pMoveX,pMoveY,pMoveZ]);
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ);

            //DRAW HORIZONTAL HANDLE FOR PADEL
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0.4,0.75]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[1,0.05,0.05]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0); 

            //DRAW VERTICAL HANDLE FOR PADEL 1
            mat4.translate(modelViewMatrix,modelViewMatrix,[1.0,-19,0]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.075,20,1.0]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            //DRAW VERTICAL HANDLE FOR PADEL 2
            mat4.translate(modelViewMatrix,modelViewMatrix,[-26,0,0]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[1.0,1,1.0]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            //DRAW SMALL HANDLE BESIDE PADEL 1
            mat4.translate(modelViewMatrix,modelViewMatrix,[-1.5,-1,0]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[2.5,0.05,1]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            //DRAW SMALL HANDLE BESIDE PADEL 2
            mat4.translate(modelViewMatrix,modelViewMatrix,[12,1,0]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[1,1,1]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // Rotate TYRE blades (grandchild) on button clicked
            mat4.rotateX(modelViewMatrix,modelViewMatrix,transformGrandZ);
            //DRAW PADEL 1
            mat4.scale(modelViewMatrix,modelViewMatrix,[2,3,6]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[1,0,0]);
            
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            //DRAW PADEL 2
            mat4.scale(modelViewMatrix,modelViewMatrix,[1,1,1]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[-8.25,0,0]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
          
            // ********************************************
            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create();

            // replace colorsBuffer with new color (the "greenColors")(purple)
            colorsBuffer = initBuffers(gl,positionsBox,greenColors);

            // Translate Parent object on slider
            mat4.translate(modelViewMatrix,modelViewMatrix,[pMoveX,pMoveY,pMoveZ]);
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ);

            //mat4.rotateY(modelViewMatrix,modelViewMatrix,90 * 0.0174533);

            // DRAW ROTATED SPINE
            // Change rotation pivot to back towards -z axis a bit
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,3]);
            // Rotate spine (child) on button clicked
            mat4.rotateY(modelViewMatrix,modelViewMatrix,transformChildY);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.15,1,0.15]);
            // z=0.3: Change back pivot
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0.6,0]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // DRAW ROTATED HANDLE
            mat4.scale(modelViewMatrix,modelViewMatrix,[7,0.1,1]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,10,0]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // DRAW ROTATED TYRE HOLDER
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.4,1,1]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,-20,0]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // DRAW ROTATED TYRE HOLDER 1
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.2,8.2,1]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[5,-0.5,0]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // DRAW ROTATED TYRE HOLDER 2
            mat4.scale(modelViewMatrix,modelViewMatrix,[1,1,1]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[-10,0,0]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);


            // ********************************************
            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create();

            // replace colorsBuffer with new color (the "redColors")(wheelfrontcolor)
            colorsBuffer = initBuffers(gl,positionsBox,redColors);

            // Translate Parent object on slider
            mat4.translate(modelViewMatrix,modelViewMatrix,[pMoveX,pMoveY,pMoveZ]);
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ);

            // Change rotation pivot to back towards -z axis a bit
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,3]);
            // Rotate front TYRE (child) on button clicked
            mat4.rotateY(modelViewMatrix,modelViewMatrix,transformChildY);
            
           

            // DRAW TYRE CENTER
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.2,0.2,0.2]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,-8,0]);
            // Rotate TYRE blades (grandchild) on button clicked
            mat4.rotateX(modelViewMatrix,modelViewMatrix,transformGrandZ);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // DRAW TYRE TOP
            mat4.scale(modelViewMatrix,modelViewMatrix,[1,0.5,3]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,7,0]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // DRAW TYRE FRONT
            mat4.scale(modelViewMatrix,modelViewMatrix,[1,5.5,0.18]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,-1.25,6.5]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // DRAW TYRE BACK
            mat4.scale(modelViewMatrix,modelViewMatrix,[1,1,1]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,-13]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

           // DRAW TYRE BOTTOM
            mat4.scale(modelViewMatrix,modelViewMatrix,[1,0.25,5.3]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,-5,1.23]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

 
            // ********************************************
            // Reset modelViewMatrix to draw another object
             modelViewMatrix = mat4.create();

            // replace colorsBuffer with new color (the "greenColors")(wheelback spinecolor)
            colorsBuffer = initBuffers(gl,positionsBox,greyColors);

            // Translate Parent object on slider
            mat4.translate(modelViewMatrix,modelViewMatrix,[pMoveX,pMoveY,pMoveZ]);
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ);

            //mat4.rotateY(modelViewMatrix,modelViewMatrix,90 * 0.0174533);

            // DRAW BACK SPINE BASE
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0.8,0.11]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.2,0.6,0.12]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,-1.15,-15]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);


            // DRAW BACK TYRE HANDLER
            mat4.scale(modelViewMatrix,modelViewMatrix,[5.0,0.1,1]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,20,0]);
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.4,1.5,1.3]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,-20,0]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // DRAW BACK TYRE HOLDER 1
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.2,8.2,1]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[5,-0.5,0]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // DRAW BACK TYRE HOLDER 2
            mat4.scale(modelViewMatrix,modelViewMatrix,[1,1,1]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[-10,0,0]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);    
          
       

            // ********************************************
            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create();

            // replace colorsBuffer with new color (the "redColors")(wheelback color)
            colorsBuffer = initBuffers(gl,positionsBox,redColors);

            // Translate Parent object on slider
            mat4.translate(modelViewMatrix,modelViewMatrix,[pMoveX,pMoveY,pMoveZ]);
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ);


            // DRAW TYRE CENTER
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.2,0.2,0.2]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,-8,-8.5]);
            // Rotate TYRE (grandchild) on button clicked
            mat4.rotateX(modelViewMatrix,modelViewMatrix,transformGrandZ);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // DRAW SECOND TYRE TOP
            mat4.scale(modelViewMatrix,modelViewMatrix,[1,0.5,3]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,7,0]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // DRAW SECOND TYRE FRONT
            mat4.scale(modelViewMatrix,modelViewMatrix,[1,5.5,0.18]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,-1.25,6.5]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // DRAW SECOND TYRE BACK
            mat4.scale(modelViewMatrix,modelViewMatrix,[1,1,1]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,-13]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // DRAW SECOND TYRE BOTTOM
            mat4.scale(modelViewMatrix,modelViewMatrix,[1,0.25,5.3]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,-5,1.23]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

                        
                        
            // ********************************************
            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create();

            // Translate Parent object on slider
            mat4.translate(modelViewMatrix,modelViewMatrix,[pMoveX,pMoveY,pMoveZ]);
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ);

            // replace colorsBuffer with new color (the "redColors2") with 1.0 alpha
            var redColors2 = [
                [0.990, 0.990, 0, 1.0],
                [0.990, 0.990, 0, 1.0],
                [0.880, 0.880, 0, 1.0],
                [0.880, 0.880, 0, 1.0],
                [0.770,0.770, 0, 1.0],
                [0.770, 0.770, 0, 1.0],
            ];
            colorsBuffer = initBuffers(gl,positionsBox,redColors2);

            // DRAW SEAT
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.5,0.15,0.7]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,5,-0.5]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            //back seat color
            colorsBuffer = initBuffers(gl,positionsBox,purpleColors);
            //DRAW BACK SEAT
            mat4.scale(modelViewMatrix,modelViewMatrix,[1.5,1.2,0.5]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0.2,-1.2]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // ********************************************
            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create();
                       
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ);
                        
            //road color
            colorsBuffer = initBuffers(gl,positionsBox,maroonColors);
            //DRAW ROAD
            mat4.scale(modelViewMatrix,modelViewMatrix,[3.0,0.5,20]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,-5.85,0.17]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            //road line color
            colorsBuffer = initBuffers(gl,positionsBox,redColors2);
            //DRAW ROAD's LINES
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.06,1,1]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[13,0.1,0]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[-26,0,0]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            //lamp Color
            colorsBuffer = initBuffers(gl,positionsBox,darkColors);
            //DRAW STREET LAMP BASES
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.75,3,0.0075]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[47,1.2,-80]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,40]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,40]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,40]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[-58.5,0,-120]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,40]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,40]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,40]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            //DRAW STREET LAMP POLES
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.65,2,0.65]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[90,1.5,-184.62]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,61.54]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,61.54]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,61.54]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[-90,0,-184.62]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,61.54]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,61.54]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,61.54]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            //DRAW STREET LAMP HEADS
            mat4.scale(modelViewMatrix,modelViewMatrix,[9,0.04,4]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[8.9,26,-46]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,15.33]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,15.33]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,15.33]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[-7.8,0,-46]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,15.33]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,15.33]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,15.33]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            //DRAW STREET LAMP LIGHT BULBS
            colorsBuffer = initBuffers(gl,positionsBox,redColors2);

            mat4.scale(modelViewMatrix,modelViewMatrix,[0.55,0.5,1.0]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[13.35,-4,-46]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,15.33]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,15.33]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,15.33]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[-12.55,0,-46]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,15.33]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,15.33]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[0,0,15.33]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            // ********************************************
            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create();
                       
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ);
                        
            //snow color
            colorsBuffer = initBuffers(gl,positionsBox,greyColors);

            //DRAW SNOWS
            mat4.scale(modelViewMatrix,modelViewMatrix,[0.05,0.05,0.05]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[0,70,-180]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[-50,30,20]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[110,-20,20]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[-150,-10,20]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[100,40,20]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[70,-10,20]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[-130,-50,20]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[50,30,20]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[80,30,20]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[-90,0,-40]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[-50,-30,20]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[110,-20,20]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[-150,-10,20]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[100,40,20]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[70,-10,20]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[-130,-50,20]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[50,30,20]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[80,30,20]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[-90,0,-40]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            // ********************************************
            // Reset modelViewMatrix to draw another object
            modelViewMatrix = mat4.create();
                                    
            // Drag mouse to rotateX & rotateY
            mat4.rotateX(modelViewMatrix,modelViewMatrix,rotateX);
            mat4.rotateY(modelViewMatrix,modelViewMatrix,rotateY);
            mat4.rotateZ(modelViewMatrix,modelViewMatrix,rotateZ);

            //grass color
            colorsBuffer = initBuffers(gl,positionsBox,darkgreenColors);

            //DRAW SIDE GRASSES
            mat4.scale(modelViewMatrix,modelViewMatrix,[3,0.1,20]);
            mat4.translate(modelViewMatrix,modelViewMatrix,[2,-26,0.175]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)

            mat4.translate(modelViewMatrix,modelViewMatrix,[-4,0,0]);
            drawScene(gl, programInfo, colorsBuffer, modelViewMatrix, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0)
            
        }



         // Array for variance of greyColors
         var greyColors = [
            [1, 1, 1, 1.0],
            [1, 1, 1, 1.0],
            [1, 1, 1, 1.0],
            [1, 1, 1, 1.0],
            [1, 1, 1, 1.0],
            [1, 1, 1, 1.0],
        ];

        var darkColors = [
            [0.7, 0.7, 0.7, 1.0],
            [0.7, 0.7, 0.7, 1.0],
            [0.71, 0.71, 0.71, 1.0],
            [0.71, 0.71, 0.71, 1.0],
            [0.72, 0.72, 0.72, 1.0],
            [0.72, 0.72, 0.72, 1.0],
        ];

        // Array for variance of greenColors
        var greenColors = [
            [0.698, 0, 0.929, 1.0],
            [0.698, 0, 0.929, 1.0],
            [0.688, 0, 0.919, 1.0],
            [0.688, 0, 0.919, 1.0],
            [0.678, 0, 0.909, 1.0],
            [0.678, 0, 0.909, 1.0],
        ];
    

        // Array for variance of redColors
        var redColors = [
            [1, 0.384, 0.121, 1.0],
            [1, 0.384, 0.121, 1.0],
            [1, 0.374, 0.111, 1.0],
            [1, 0.374, 0.111, 1.0],
            [1, 0.364, 0.101, 1.0],
            [1, 0.364, 0.101, 1.0],

        ];

        // Array for variance of redColors
        var maroonColors = [
            [0.5, 0, 0, 1.0],
            [0.5, 0, 0, 1.0],
            [0.55, 0.2, 0.2, 1.0],
            [0.5, 0, 0, 1.0],
            [0.5, 0, 0, 1.0],
            [0.5, 0, 0, 1.0],
        ];

        var maroonColors = [
            [0.5, 0, 0, 1.0],
            [0.5, 0, 0, 1.0],
            [0.55, 0.2, 0.2, 1.0],
            [0.5, 0, 0, 1.0],
            [0.5, 0, 0, 1.0],
            [0.5, 0, 0, 1.0],
        ];

        var darkgreenColors = [
            [0, 0.39, 0, 1.0],
            [0, 0.39, 0, 1.0],
            [0, 0.15, 0, 1.0],
            [0, 0.39, 0, 1.0],
            [0, 0.39, 0, 1.0],
            [0, 0.39, 0, 1.0],
        ];

        var yellowColors = [
            [0.98, 0.98, 0.2, 1.0],
            [0.98, 0.98, 0.2, 1.0],
            [0.99, 0.99, 0.21, 1.0],
            [0.99, 0.99, 0.21, 1.0],
            [1.0, 1.0, 0.22, 1.0],
            [1.0, 1.0, 0.22, 1.0],
        ];

        var purpleColors = [ 
                [0.952, 0.494, 0.968, 1.0],    
                [0.952, 0.494, 0.968, 1.0],   
                [0.942, 0.484, 0.958, 1.0],   
                [0.942, 0.484, 0.958, 1.0],  
                [0.932, 0.474, 0.948, 1.0],
                [0.932, 0.474, 0.948, 1.0],
            ];

        var rotateX = 0, rotateY = 0, rotateZ = 0;

        // Mouse drag to rotateX & rotateY
        // *******************************
        var prevx, prevy, canvas;
        var dragging = false;

        function doMouseDown(evt) {
            if (dragging)
                return;
            dragging = true;
            document.addEventListener("mousemove", doMouseDrag, false);
            document.addEventListener("mouseup", doMouseUp, false);
            var box = canvas.getBoundingClientRect();
            prevx = window.pageXOffset + evt.clientX - box.left;
            prevy = window.pageYOffset + evt.clientY - box.top;
        }

        function doMouseDrag(evt) {
            if (!dragging)
                return;
            var box = canvas.getBoundingClientRect();
            var x = window.pageXOffset + evt.clientX - box.left;
            var y = window.pageYOffset + evt.clientY - box.top;
            let diffy = (prevx - x) * 0.01;
            let diffx = (prevy - y) * 0.01;
            prevx = x;
            prevy = y;
            rotateX = rotateX - diffx;
            rotateY = rotateY - diffy;
            main();
        }

        function doMouseUp(evt) {
            if (dragging) {
                document.removeEventListener("mousemove", doMouseDrag, false);
                document.removeEventListener("mouseup", doMouseUp, false);
                dragging = false;
            }
        }

        function resetRotation() {
            rotateX = 0, rotateY = 0, rotateZ = 0;
            main();
        }
        // *******************************

        window.onload = main;

        // ########################################### //
        // initBuffers
        //
        // Initialize the buffers we'll need. For this demo, we just
        // have one object -- a simple three-dimensional cube.
        //
        function initBuffers(gl,positions,faceColors) {

            // Create a buffer for the square's positions.
            const positionBuffer = gl.createBuffer();

            // Select the positionBuffer as the one to apply buffer
            // operations to from here out.
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

            // Now pass the list of positions into WebGL to build the
            // shape. We do this by creating a Float32Array from the
            // JavaScript array, then use it to fill the current buffer.
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            // ** LIGHTING **
            // Set up the normals for the vertices, so that we can compute lighting.
            const normalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);

            // ** LIGHTING **
            const vertexNormals = [
                // Front
                0.0,  0.0,  1.0,
                0.0,  0.0,  1.0,
                0.0,  0.0,  1.0,
                0.0,  0.0,  1.0,

                // Back
                0.0,  0.0, -1.0,
                0.0,  0.0, -1.0,
                0.0,  0.0, -1.0,
                0.0,  0.0, -1.0,

                // Top
                0.0,  0.6,  0.0,
                0.0,  0.6,  0.0,
                0.0,  0.6,  0.0,
                0.0,  0.6,  0.0,

                // Bottom
                0.0, -1.0,  0.0,
                0.0, -1.0,  0.0,
                0.0, -1.0,  0.0,
                0.0, -1.0,  0.0,

                // Right
                1.0,  0.0,  0.0,
                1.0,  0.0,  0.0,
                1.0,  0.0,  0.0,
                1.0,  0.0,  0.0,

                // Left
                -1.0,  0.0,  0.0,
                -1.0,  0.0,  0.0,
                -1.0,  0.0,  0.0,
                -1.0,  0.0,  0.0
            ];

            // ** LIGHTING **
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals), gl.STATIC_DRAW);

            // Color buffer
            var colors = [];

            for (var j = 0; j < faceColors.length; ++j) {
                const c = faceColors[j];
                colors = colors.concat(c, c, c, c);
            }

            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

            // Build the element array buffer; this specifies the indices
            // into the vertex arrays for each face's vertices.
            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

            // This array defines each face as two triangles, using the
            // indices into the vertex array to specify each triangle's
            // position.
            const indices = [
                0,  1,  2,      0,  2,  3,    // front
                4,  5,  6,      4,  6,  7,    // back
                8,  9,  10,     8,  10, 11,   // top
                12, 13, 14,     12, 14, 15,   // bottom
                16, 17, 18,     16, 18, 19,   // right
                20, 21, 22,     20, 22, 23,   // left
            ];

            // Now send the element array to GL

            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            return {
                position: positionBuffer,
                normal: normalBuffer, // ** LIGHTING **
                color: colorBuffer,
                indices: indexBuffer,
            };
        }

        // ########################################### //
        // Draw the scene.
        //
        function drawScene(gl, programInfo, buffers, modelViewMatrix, projectionMatrix) {
            // Tell WebGL how to pull out the positions from the position
            // buffer into the vertexPosition attribute.
            {
                const numComponents = 3; // (x,y,z)
                const type = gl.FLOAT;
                const normalize = false;
                const stride = 0;
                const offset = 0;
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexPosition,
                    numComponents,
                    type,
                    normalize,
                    stride,
                    offset);
                gl.enableVertexAttribArray(
                    programInfo.attribLocations.vertexPosition);
            }

            // Tell WebGL how to pull out the colors from the color buffer
            // into the vertexColor attribute.
            {
                const numComponents = 4; // (r,g,b,a)
                const type = gl.FLOAT;
                const normalize = false;
                const stride = 0;
                const offset = 0;
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexColor,
                    numComponents,
                    type,
                    normalize,
                    stride,
                    offset);
                gl.enableVertexAttribArray(
                    programInfo.attribLocations.vertexColor);
            }

            // ** LIGHTING ** Start ---
            var normalMatrix = mat4.create();
            mat4.invert(normalMatrix, modelViewMatrix);
            mat4.transpose(normalMatrix, normalMatrix);

            // Tell WebGL how to pull out the normals from
            // the normal buffer into the vertexNormal attribute.
            {
                const numComponents = 3; // (x, y, z)
                const type = gl.FLOAT;
                const normalize = false;
                const stride = 0;
                const offset = 0;
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normal);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexNormal,
                    numComponents,
                    type,
                    normalize,
                    stride,
                    offset);
                gl.enableVertexAttribArray(
                    programInfo.attribLocations.vertexNormal);
            }
            // ** LIGHTING ** Finish ---

            // Tell WebGL which indices to use to index the vertices
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);

            // Tell WebGL to use our program when drawing
            gl.useProgram(programInfo.program);

            // Set the shader uniforms
            gl.uniformMatrix4fv(
                programInfo.uniformLocations.projectionMatrix,
                false,
                projectionMatrix);
            gl.uniformMatrix4fv(
                programInfo.uniformLocations.modelViewMatrix,
                false,
                modelViewMatrix);

            // ** LIGHTING **
            gl.uniformMatrix4fv(
                programInfo.uniformLocations.normalMatrix,
                false,
                normalMatrix);
        }

        // ########################################### //
        // Initialize a shader program, so WebGL knows how to draw our data
        //
        function initShaderProgram(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

            // Create the shader program
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            // If creating the shader program failed, alert
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                return null;
            }

            return shaderProgram;
        }

        // ########################################### //
        // creates a shader of the given type, uploads the source and
        // compiles it.
        //
        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);

            // Send the source to the shader object
            gl.shaderSource(shader, source);

            // Compile the shader program
            gl.compileShader(shader);

            // See if it compiled successfully
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        var transformChildY = 0, transformGrandZ = 0;
        var rotationSpeed = 1, transparencyValue = 1;
        var translateZ = 0, scaleY = 1, rotateObject = 0;

        // ########################################### //
        // PARENT & CAMERA MOVEMENT functions
        // ########################################### //

        var pMoveX = 0, pMoveY = 0, pMoveZ = 0;
        var cMoveX = 0, cMoveY = 0, cMoveZ = 10;

        function changeP1value() {
            pMoveX = document.getElementById("p1Value").value;
            document.getElementById("pMoveX").innerHTML = document.getElementById("p1Value").value;
            main();
        }

        function changeC1value() {
            cMoveX = document.getElementById("c1Value").value;
            document.getElementById("cMoveX").innerHTML = document.getElementById("c1Value").value;
            main();
        }

        function changeP2value() {
            pMoveY = document.getElementById("p2Value").value;
            document.getElementById("pMoveY").innerHTML = document.getElementById("p2Value").value;
            main();
        }

        function changeC2value() {
            cMoveY = document.getElementById("c2Value").value;
            document.getElementById("cMoveY").innerHTML = document.getElementById("c2Value").value;
            main();
        }

        function changeP3value() {
            pMoveZ = document.getElementById("p3Value").value;
            document.getElementById("pMoveZ").innerHTML = document.getElementById("p3Value").value;
            main();
        }

        function changeC3value() {
            cMoveZ = document.getElementById("c3Value").value;
            document.getElementById("cMoveZ").innerHTML = document.getElementById("c3Value").value;
            main();
        }


        // ########################################### //
        // TRANSFORMATION functions
        // ########################################### //

        var transformGrandBool = false, transformChildBool = false;
        var timerGrand = 0, timerChild = 0;

        // Transform Grandchild on/off switch
        function transformGrand() {
            if (transformGrandBool == false) { transformGrandBool = true; }
            else { transformGrandBool = false; }

            if (transformGrandBool == true) {
                timerGrand = setInterval(function(){ transformGrandLoop() }, 10);
                document.getElementById("grandBtn").value = "Stop (GRANDCHILD)";
            } else {
                clearInterval(timerGrand);
                document.getElementById("grandBtn").value = "GRANDCHILD";
            }
        }

        // Transform Grandchild by rotation on Z axis
        function transformGrandLoop() {
            transformGrandZ = transformGrandZ + (rotationSpeed * 0.0174533);
            main();
        }

        // Transform Child on/off switch
        function transformChild() {
            if (transformChildBool == false) { transformChildBool = true; }
            else { transformChildBool = false; }

            if (transformChildBool == true) {
                timerChild = setInterval(function(){ transformChildLoop() }, 10);
                document.getElementById("childBtn").value = "Stop (CHILD)";
            } else {
                clearInterval(timerChild);
                document.getElementById("childBtn").value = "CHILD";
            }
        }

        // Transform Child by rotation on Y axis
        var rotateClockwise = false;
        function transformChildLoop() {

            if (rotateClockwise == true) {
                transformChildY = transformChildY - (0.3 * 0.0174533);
                if (transformChildY < -1) {
                    rotateClockwise = false;
                }
            } else {
                transformChildY = transformChildY + (0.3 * 0.0174533);
                if (transformChildY > 1) {
                    rotateClockwise = true;
                }
            }
            main();
        }

        // Speed SLIDER functions
        function changeS1value() {
            // pass slider value into global variable "rotationSpeed"
            rotationSpeed = document.getElementById("s1Value").value;
            // change "speedValue" label/span
            document.getElementById("speedValue").innerHTML = document.getElementById("s1Value").value;
            // calling the transformGrandLoop() function
            transformGrandLoop();
        }

        // ########################################### //
        // COLOR functions
        // ########################################### //

        var colorGrandBool = false, colorChildBool = false;

        // Change color for Grandchild object
        function colorGrand() {
            if (colorGrandBool == false) { colorGrandBool = true; }
            else { colorGrandBool = false; }

            if (colorGrandBool == true) {
                redColors = [
                    [1, 0, 0, transparencyValue],
                    [1, 0, 0, transparencyValue],
                    [1, 0, 0, transparencyValue],
                    [1, 0, 0, transparencyValue],
                    [1, 0, 0, transparencyValue],
                    [1, 0, 0, transparencyValue],
                ];
                document.getElementById("grandBtn2").value = "Revert (GRANDCHILD)";
            } else {
                redColors = [
                    [0.945, 0.541, 0.117, 1.0],
                    [0.945, 0.541, 0.117, 1.0],
                    [0.945, 0.541, 0.117, 1.0],
                    [0.945, 0.541, 0.117, 1.0],
                    [0.945, 0.541, 0.117, 1.0],
                    [0.945, 0.541, 0.117, 1.0],
                ];
                document.getElementById("grandBtn2").value = "GRANDCHILD";
            }

            main();
        }

        // Change color for Child object
        function colorChild() {
            if (colorChildBool == false) { colorChildBool = true; }
            else { colorChildBool = false; }

            if (colorChildBool == true) {
                greenColors = [
                    [0, 1, 0, 1.0],
                    [0, 1, 0, 1.0],
                    [0, 1, 0, 1.0],
                    [0, 1, 0, 1.0],
                    [0, 1, 0, 1.0],
                    [0, 1, 0, 1.0],
                ];
                document.getElementById("childBtn2").value = "Revert (CHILD)";
            } else {
                greenColors = [
                    [0.698, 0, 0.929, 1.0],
                    [0.698, 0, 0.929, 1.0],
                    [0.688, 0, 0.919, 1.0],
                    [0.688, 0, 0.919, 1.0],
                    [0.678, 0, 0.909, 1.0],
                    [0.678, 0, 0.909, 1.0],
                ];
                document.getElementById("childBtn2").value = "CHILD";
            }

            main();
        }

        // Alpha SLIDER functions
        function changeS2value() {
            // pass slider value into global variable "transparencyValue"
            transparencyValue = document.getElementById("s2Value").value / 10;
            // change "alphaValue" label/span
            document.getElementById("alphaValue").innerHTML = transparencyValue;
            // calling the colorGrand() function
            if (colorGrandBool == false) { colorGrandBool = true; }
            else { colorGrandBool = false; }
            colorGrand();
        }

    </script>
</head>

<body style="font-family: Arial, Helvetica, sans-serif; text-align: center;">
    <div style="padding: 10px 0px 10px 0px;">
        <div style="padding-bottom:7px; font-size:0.8em;">Drag mouse inside canvas to rotate PARENT on x-axis and y-axis</div>
        <input type="button" style="margin:1px; width:23%;" id="resetBtn" value="Reset rotation" onclick="resetRotation()">
    </div>
    <canvas id="glCanvas" width="640" height="480"></canvas>
    <br><br>
    <table width="640" cellpadding="0" cellspacing="5" border="0" align="center">
        <tr>
            <td align="center" style="font-size:0.8em;">PARENT movement (x-axis): <span id="pMoveX">0</span>
                <input oninput="changeP1value()" id="p1Value" type="range" min="-10" max="10" value="0" style="width: 100%"></td>
            <td rowspan="3" width="5%" style="border-right: 1px dashed #999;"></td>
            <td rowspan="3" width="3%"></td>
            <td align="center" style="font-size:0.8em;">CAMERA movement (x-axis): <span id="cMoveX">0</span>
                <input oninput="changeC1value()" id="c1Value" type="range" min="-10" max="10" value="0" style="width: 100%"></td>
        </tr>
        <tr>
            <td align="center" style="font-size:0.8em;">PARENT movement (y-axis): <span id="pMoveY">0</span>
                <input oninput="changeP2value()" id="p2Value" type="range" min="-10" max="10" value="0" style="width: 100%"></td>
            <td align="center" style="font-size:0.8em;">CAMERA movement (y-axis): <span id="cMoveY">0</span>
                <input oninput="changeC2value()" id="c2Value" type="range" min="-10" max="10" value="0" style="width: 100%"></td>
        </tr>
        <tr>
            <td align="center" style="font-size:0.8em;">PARENT movement (z-axis): <span id="pMoveZ">0</span>
                <input oninput="changeP3value()" id="p3Value" type="range" min="-10" max="10" value="0" style="width: 100%"></td>
            <td align="center" style="font-size:0.8em;">CAMERA movement (z-axis): <span id="cMoveZ">10</span>
                <input oninput="changeC3value()" id="c3Value" type="range" min="-10" max="10" value="10" style="width: 100%"></td>
        </tr>
    </table>
    <table width="640" cellpadding="0" cellspacing="5" border="0" align="center">
        <tr><td colspan="2"><hr></td></tr>
        <tr>
            <td width="40%" align="right">Perform transformation: </td>
            <td>
                <input type="button" style="margin:5px; width:45%;" id="childBtn" value="CHILD" onclick="transformChild()">
                <input type="button" style="margin:5px; width:45%;" id="grandBtn" value="GRANDCHILD" onclick="transformGrand()">
            </td>
        </tr>
        <tr>
            <td align="right" style="font-size:0.8em;">GRANDCHILD transformation speed: <span id="speedValue">1</span></td>
            <td><input oninput="changeS1value()" id="s1Value" type="range" min="1" max="10" value="0" style="width: 100%"></td>
        </tr>
        <tr><td colspan="2"><hr></td></tr>
        <tr>
            <td align="right">Change color: </td>
            <td>
                <input type="button" style="margin:5px; width:45%;" id="childBtn2" value="CHILD" onclick="colorChild()">
                <input type="button" style="margin:5px; width:45%;" id="grandBtn2" value="GRANDCHILD" onclick="colorGrand()">
            </td>
        </tr>
        <tr>
            <td align="right" style="font-size:0.8em;">GRANDCHILD alpha value: <span id="alphaValue">1</span></td>
            <td><input oninput="changeS2value()" id="s2Value" type="range" min="0" max="10" value="10" style="width: 100%"></td>
        </tr>
    </table>
</body>
